
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>types: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/comdex-official/comdex/x/asset/types/asset.go (100.0%)</option>
				
				<option value="file1">github.com/comdex-official/comdex/x/asset/types/asset.pb.go (0.9%)</option>
				
				<option value="file2">github.com/comdex-official/comdex/x/asset/types/codec.go (0.0%)</option>
				
				<option value="file3">github.com/comdex-official/comdex/x/asset/types/events.pb.go (1.4%)</option>
				
				<option value="file4">github.com/comdex-official/comdex/x/asset/types/genesis.go (100.0%)</option>
				
				<option value="file5">github.com/comdex-official/comdex/x/asset/types/genesis.pb.go (0.8%)</option>
				
				<option value="file6">github.com/comdex-official/comdex/x/asset/types/gov.go (15.4%)</option>
				
				<option value="file7">github.com/comdex-official/comdex/x/asset/types/gov.pb.go (0.9%)</option>
				
				<option value="file8">github.com/comdex-official/comdex/x/asset/types/keys.go (66.7%)</option>
				
				<option value="file9">github.com/comdex-official/comdex/x/asset/types/msg.go (88.1%)</option>
				
				<option value="file10">github.com/comdex-official/comdex/x/asset/types/msg.pb.go (0.8%)</option>
				
				<option value="file11">github.com/comdex-official/comdex/x/asset/types/pair.go (100.0%)</option>
				
				<option value="file12">github.com/comdex-official/comdex/x/asset/types/pair.pb.go (0.9%)</option>
				
				<option value="file13">github.com/comdex-official/comdex/x/asset/types/params.go (43.8%)</option>
				
				<option value="file14">github.com/comdex-official/comdex/x/asset/types/params.pb.go (1.2%)</option>
				
				<option value="file15">github.com/comdex-official/comdex/x/asset/types/querier.pb.go (0.9%)</option>
				
				<option value="file16">github.com/comdex-official/comdex/x/asset/types/querier.pb.gw.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package types

import (
        "fmt"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/errors"
)

const (
        MaxAssetNameLength = 16
)

func (m *Asset) Validate() error <span class="cov8" title="1">{
        if m.Id == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("id cannot be zero")
        }</span>
        <span class="cov8" title="1">if m.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("name cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; MaxAssetNameLength </span><span class="cov8" title="1">{
                return fmt.Errorf("name length cannot be greater than %d", MaxAssetNameLength)
        }</span>
        <span class="cov8" title="1">if m.Denom == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("denom cannot be empty")
        }</span>
        <span class="cov8" title="1">if err := sdk.ValidateDenom(m.Denom); err != nil </span><span class="cov8" title="1">{
                return errors.Wrapf(err, "invalid denom %s", m.Denom)
        }</span>
        <span class="cov8" title="1">if m.Decimals &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("decimals cannot be less than zero")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/asset/v1beta1/asset.proto

package types

import (
        fmt "fmt"
        _ "github.com/gogo/protobuf/gogoproto"
        proto "github.com/gogo/protobuf/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Asset struct {
        Id       uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Name     string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" yaml:"name"`
        Denom    string `protobuf:"bytes,3,opt,name=denom,proto3" json:"denom,omitempty" yaml:"denom"`
        Decimals int64  `protobuf:"varint,4,opt,name=decimals,proto3" json:"decimals,omitempty" yaml:"decimals"`
}

func (m *Asset) Reset()         <span class="cov0" title="0">{ *m = Asset{} }</span>
func (m *Asset) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Asset) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Asset) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_67277aee9bd3eed4, []int{0}
}</span>
func (m *Asset) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Asset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Asset.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Asset) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Asset.Merge(m, src)
}</span>
func (m *Asset) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Asset) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Asset.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Asset proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Asset)(nil), "comdex.asset.v1beta1.Asset")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("comdex/asset/v1beta1/asset.proto", fileDescriptor_67277aee9bd3eed4) }</span>

var fileDescriptor_67277aee9bd3eed4 = []byte{
        // 265 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x3c, 0xd0, 0x31, 0x4e, 0xc3, 0x30,
        0x18, 0x05, 0xe0, 0x38, 0x4d, 0x11, 0x18, 0x44, 0x91, 0xe9, 0x10, 0x31, 0x38, 0x91, 0x91, 0x50,
        0x16, 0x62, 0x55, 0x6c, 0x6c, 0xe4, 0x06, 0x64, 0x64, 0x73, 0x62, 0x37, 0x58, 0x8a, 0xeb, 0x8a,
        0x18, 0x44, 0x6f, 0xc1, 0xc2, 0x1d, 0x38, 0x4a, 0xc7, 0x8e, 0x4c, 0x11, 0x24, 0x37, 0xc8, 0x09,
        0x50, 0xec, 0x96, 0xcd, 0xff, 0x7b, 0xdf, 0xf2, 0x0c, 0xe3, 0x52, 0x2b, 0x2e, 0xde, 0x29, 0x6b,
        0x1a, 0x61, 0xe8, 0xdb, 0xa2, 0x10, 0x86, 0x2d, 0xdc, 0x95, 0xae, 0x5f, 0xb4, 0xd1, 0x68, 0xee,
        0x44, 0xea, 0xb2, 0xbd, 0xb8, 0x9a, 0x57, 0xba, 0xd2, 0x16, 0xd0, 0xf1, 0xe5, 0x2c, 0xf9, 0x04,
        0x70, 0xfa, 0x30, 0x3a, 0x74, 0x0e, 0x7d, 0xc9, 0x43, 0x10, 0x83, 0x24, 0xc8, 0x7d, 0xc9, 0xd1,
        0x35, 0x0c, 0x56, 0x4c, 0x89, 0xd0, 0x8f, 0x41, 0x72, 0x92, 0xcd, 0x86, 0x36, 0x3a, 0xdd, 0x30,
        0x55, 0xdf, 0x93, 0x31, 0x25, 0xb9, 0x2d, 0xd1, 0x0d, 0x9c, 0x72, 0xb1, 0xd2, 0x2a, 0x9c, 0x58,
        0x75, 0x31, 0xb4, 0xd1, 0x99, 0x53, 0x36, 0x26, 0xb9, 0xab, 0x11, 0x85, 0xc7, 0x5c, 0x94, 0x52,
        0xb1, 0xba, 0x09, 0x83, 0x18, 0x24, 0x93, 0xec, 0x72, 0x68, 0xa3, 0xd9, 0x81, 0xba, 0x86, 0xe4,
        0xff, 0x28, 0x7b, 0xdc, 0xfe, 0x62, 0xef, 0xab, 0xc3, 0xde, 0xb6, 0xc3, 0x60, 0xd7, 0x61, 0xf0,
        0xd3, 0x61, 0xf0, 0xd1, 0x63, 0x6f, 0xd7, 0x63, 0xef, 0xbb, 0xc7, 0xde, 0x13, 0xad, 0xa4, 0x79,
        0x7e, 0x2d, 0xd2, 0x52, 0x2b, 0xea, 0x06, 0xdf, 0xea, 0xe5, 0x52, 0x96, 0x92, 0xd5, 0xfb, 0x9b,
        0x1e, 0x3e, 0xc9, 0x6c, 0xd6, 0xa2, 0x29, 0x8e, 0xec, 0xe2, 0xbb, 0xbf, 0x00, 0x00, 0x00, 0xff,
        0xff, 0x7b, 0x4e, 0x23, 0x3e, 0x41, 0x01, 0x00, 0x00,
}

func (m *Asset) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Asset) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Asset) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Decimals != 0 </span><span class="cov0" title="0">{
                i = encodeVarintAsset(dAtA, i, uint64(m.Decimals))
                i--
                dAtA[i] = 0x20
        }</span>
        <span class="cov0" title="0">if len(m.Denom) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Denom)
                copy(dAtA[i:], m.Denom)
                i = encodeVarintAsset(dAtA, i, uint64(len(m.Denom)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.Name) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintAsset(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintAsset(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintAsset(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovAsset(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Asset) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovAsset(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">l = len(m.Name)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovAsset(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Denom)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovAsset(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Decimals != 0 </span><span class="cov0" title="0">{
                n += 1 + sovAsset(uint64(m.Decimals))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovAsset(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozAsset(x uint64) (n int) <span class="cov0" title="0">{
        return sovAsset(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Asset) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAsset
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Asset: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Asset: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAsset
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAsset
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAsset
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAsset
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAsset
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAsset
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAsset
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Denom = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Decimals = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAsset
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Decimals |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipAsset(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAsset
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipAsset(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowAsset
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowAsset
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowAsset
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthAsset
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupAsset
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthAsset
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthAsset        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowAsset          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupAsset = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file2" style="display: none">package types

import (
        "github.com/cosmos/cosmos-sdk/codec/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/msgservice"
        govtypes "github.com/cosmos/cosmos-sdk/x/gov/types"
)

func RegisterInterfaces(registry types.InterfaceRegistry) <span class="cov0" title="0">{
        registry.RegisterImplementations(
                (*govtypes.Content)(nil),
                &amp;UpdateAdminProposal{},
        )

        registry.RegisterImplementations(
                (*sdk.Msg)(nil),
                &amp;MsgAddAssetRequest{},
                &amp;MsgUpdateAssetRequest{},
                &amp;MsgAddPairRequest{},
                &amp;MsgUpdatePairRequest{},
        )

        msgservice.RegisterMsgServiceDesc(registry, &amp;_MsgService_serviceDesc)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/asset/v1beta1/events.proto

package types

import (
        fmt "fmt"
        _ "github.com/gogo/protobuf/gogoproto"
        proto "github.com/gogo/protobuf/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type EventAddPair struct {
        Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *EventAddPair) Reset()         <span class="cov0" title="0">{ *m = EventAddPair{} }</span>
func (m *EventAddPair) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*EventAddPair) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*EventAddPair) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_8698e7aadaab4005, []int{0}
}</span>
func (m *EventAddPair) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *EventAddPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_EventAddPair.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *EventAddPair) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_EventAddPair.Merge(m, src)
}</span>
func (m *EventAddPair) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *EventAddPair) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_EventAddPair.DiscardUnknown(m)
}</span>

var xxx_messageInfo_EventAddPair proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*EventAddPair)(nil), "comdex.asset.v1beta1.EventAddPair")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("comdex/asset/v1beta1/events.proto", fileDescriptor_8698e7aadaab4005) }</span>

var fileDescriptor_8698e7aadaab4005 = []byte{
        // 187 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x52, 0x4c, 0xce, 0xcf, 0x4d,
        0x49, 0xad, 0xd0, 0x4f, 0x2c, 0x2e, 0x4e, 0x2d, 0xd1, 0x2f, 0x33, 0x4c, 0x4a, 0x2d, 0x49, 0x34,
        0xd4, 0x4f, 0x2d, 0x4b, 0xcd, 0x2b, 0x29, 0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x12, 0x81,
        0x28, 0xd1, 0x03, 0x2b, 0xd1, 0x83, 0x2a, 0x91, 0x12, 0x49, 0xcf, 0x4f, 0xcf, 0x07, 0x2b, 0xd0,
        0x07, 0xb1, 0x20, 0x6a, 0x95, 0xe4, 0xb8, 0x78, 0x5c, 0x41, 0x7a, 0x1d, 0x53, 0x52, 0x02, 0x12,
        0x33, 0x8b, 0x84, 0xf8, 0xb8, 0x98, 0x32, 0x53, 0x24, 0x18, 0x15, 0x18, 0x35, 0x58, 0x82, 0x98,
        0x32, 0x53, 0x9c, 0x02, 0x4f, 0x3c, 0x94, 0x63, 0x58, 0xf1, 0x48, 0x8e, 0xe1, 0xc4, 0x23, 0x39,
        0xc6, 0x0b, 0x8f, 0xe4, 0x18, 0x1f, 0x3c, 0x92, 0x63, 0x9c, 0xf0, 0x58, 0x8e, 0xe1, 0xc2, 0x63,
        0x39, 0x86, 0x1b, 0x8f, 0xe5, 0x18, 0xa2, 0xf4, 0xd3, 0x33, 0x4b, 0x32, 0x4a, 0x93, 0xf4, 0x92,
        0xf3, 0x73, 0xf5, 0x21, 0x16, 0xeb, 0xe6, 0xa7, 0xa5, 0x65, 0x26, 0x67, 0x26, 0xe6, 0x40, 0xf9,
        0xfa, 0x30, 0xd7, 0x96, 0x54, 0x16, 0xa4, 0x16, 0x27, 0xb1, 0x81, 0x6d, 0x36, 0x06, 0x04, 0x00,
        0x00, 0xff, 0xff, 0x2e, 0xc4, 0xd5, 0x73, 0xca, 0x00, 0x00, 0x00,
}

func (m *EventAddPair) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *EventAddPair) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *EventAddPair) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintEvents(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovEvents(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *EventAddPair) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovEvents(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovEvents(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozEvents(x uint64) (n int) <span class="cov0" title="0">{
        return sovEvents(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *EventAddPair) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowEvents
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: EventAddPair: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: EventAddPair: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipEvents(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipEvents(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowEvents
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupEvents
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthEvents
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file4" style="display: none">package types

func NewGenesisState(assets []Asset, pairs []Pair, params Params) *GenesisState <span class="cov8" title="1">{
        return &amp;GenesisState{
                Assets:  assets,
                Pairs:   pairs,
                Params:  params,
        }
}</span>

func DefaultGenesisState() *GenesisState <span class="cov8" title="1">{
        return NewGenesisState(
                nil,
                nil,
                DefaultParams(),
        )
}</span>

func ValidateGenesis(_ *GenesisState) error <span class="cov8" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/asset/v1beta1/genesis.proto

package types

import (
        fmt "fmt"
        _ "github.com/gogo/protobuf/gogoproto"
        proto "github.com/gogo/protobuf/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type GenesisState struct {
        Assets []Asset `protobuf:"bytes,1,rep,name=assets,proto3" json:"assets" yaml:"assets"`
        Pairs  []Pair  `protobuf:"bytes,3,rep,name=pairs,proto3" json:"pairs" yaml:"pairs"`
        Params Params  `protobuf:"bytes,4,opt,name=params,proto3" json:"params" yaml:"params"`
}

func (m *GenesisState) Reset()         <span class="cov0" title="0">{ *m = GenesisState{} }</span>
func (m *GenesisState) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GenesisState) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GenesisState) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_13a69a7476a1f579, []int{0}
}</span>
func (m *GenesisState) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *GenesisState) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GenesisState.Merge(m, src)
}</span>
func (m *GenesisState) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *GenesisState) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GenesisState.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*GenesisState)(nil), "comdex.asset.v1beta1.GenesisState")
}</span>

func init() <span class="cov8" title="1">{
        proto.RegisterFile("comdex/asset/v1beta1/genesis.proto", fileDescriptor_13a69a7476a1f579)
}</span>

var fileDescriptor_13a69a7476a1f579 = []byte{
        // 300 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x52, 0x4a, 0xce, 0xcf, 0x4d,
        0x49, 0xad, 0xd0, 0x4f, 0x2c, 0x2e, 0x4e, 0x2d, 0xd1, 0x2f, 0x33, 0x4c, 0x4a, 0x2d, 0x49, 0x34,
        0xd4, 0x4f, 0x4f, 0xcd, 0x4b, 0x2d, 0xce, 0x2c, 0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x12,
        0x81, 0xa8, 0xd1, 0x03, 0xab, 0xd1, 0x83, 0xaa, 0x91, 0x12, 0x49, 0xcf, 0x4f, 0xcf, 0x07, 0x2b,
        0xd0, 0x07, 0xb1, 0x20, 0x6a, 0xa5, 0x14, 0xb0, 0x9a, 0x07, 0xd1, 0x09, 0x51, 0x21, 0x8f, 0x55,
        0x45, 0x41, 0x62, 0x66, 0x11, 0x54, 0x81, 0x22, 0x0e, 0x05, 0x45, 0x89, 0xb9, 0x50, 0x17, 0x29,
        0xbd, 0x67, 0xe4, 0xe2, 0x71, 0x87, 0xb8, 0x31, 0xb8, 0x24, 0xb1, 0x24, 0x55, 0xc8, 0x8b, 0x8b,
        0x0d, 0xac, 0xbc, 0x58, 0x82, 0x51, 0x81, 0x59, 0x83, 0xdb, 0x48, 0x5a, 0x0f, 0x9b, 0x9b, 0xf5,
        0x1c, 0x41, 0x3c, 0x27, 0xd1, 0x13, 0xf7, 0xe4, 0x19, 0x3e, 0xdd, 0x93, 0xe7, 0xad, 0x4c, 0xcc,
        0xcd, 0xb1, 0x52, 0x82, 0x68, 0x54, 0x0a, 0x82, 0x9a, 0x20, 0xe4, 0xc6, 0xc5, 0x0a, 0x72, 0x4d,
        0xb1, 0x04, 0x33, 0xd8, 0x28, 0x29, 0xec, 0x46, 0x05, 0x24, 0x66, 0x16, 0x39, 0x89, 0x40, 0x4d,
        0xe2, 0x81, 0x98, 0x04, 0xd6, 0xa6, 0x14, 0x04, 0xd1, 0x2e, 0xe4, 0xcd, 0xc5, 0x06, 0x71, 0xb4,
        0x04, 0x8b, 0x02, 0xa3, 0x06, 0xb7, 0x91, 0x0c, 0x2e, 0x83, 0x40, 0x6a, 0xd0, 0x1d, 0x05, 0xd1,
        0xa9, 0x14, 0x04, 0x35, 0xc2, 0x29, 0xf0, 0xc4, 0x43, 0x39, 0x86, 0x15, 0x8f, 0xe4, 0x18, 0x4e,
        0x3c, 0x92, 0x63, 0xbc, 0xf0, 0x48, 0x8e, 0xf1, 0xc1, 0x23, 0x39, 0xc6, 0x09, 0x8f, 0xe5, 0x18,
        0x2e, 0x3c, 0x96, 0x63, 0xb8, 0xf1, 0x58, 0x8e, 0x21, 0x4a, 0x3f, 0x3d, 0xb3, 0x24, 0xa3, 0x34,
        0x09, 0x64, 0x89, 0x3e, 0xc4, 0x22, 0xdd, 0xfc, 0xb4, 0xb4, 0xcc, 0xe4, 0xcc, 0xc4, 0x1c, 0x28,
        0x5f, 0x1f, 0x16, 0xa6, 0x25, 0x95, 0x05, 0xa9, 0xc5, 0x49, 0x6c, 0xe0, 0xb0, 0x34, 0x06, 0x04,
        0x00, 0x00, 0xff, 0xff, 0xa8, 0x50, 0x95, 0x69, 0x03, 0x02, 0x00, 0x00,
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintGenesis(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x22
        if len(m.Pairs) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Pairs) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Pairs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintGenesis(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x1a</span>
                }
        }
        <span class="cov0" title="0">if len(m.Assets) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Assets) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Assets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintGenesis(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintGenesis(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovGenesis(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *GenesisState) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Assets) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Assets </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovGenesis(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if len(m.Pairs) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Pairs </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovGenesis(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">l = m.Params.Size()
        n += 1 + l + sovGenesis(uint64(l))
        return n</span>
}

func sovGenesis(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozGenesis(x uint64) (n int) <span class="cov0" title="0">{
        return sovGenesis(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *GenesisState) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Assets = append(m.Assets, Asset{})
                        if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pairs", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Pairs = append(m.Pairs, Pair{})
                        if err := m.Pairs[len(m.Pairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipGenesis(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipGenesis(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupGenesis
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthGenesis
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthGenesis        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowGenesis          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupGenesis = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file6" style="display: none">package types

import (
        "fmt"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/errors"
        govtypes "github.com/cosmos/cosmos-sdk/x/gov/types"
)

const (
        ProposalTypeUpdateAdmin = "UpdateAdmin"
)

func init() <span class="cov8" title="1">{
        govtypes.RegisterProposalType(ProposalTypeUpdateAdmin)
        govtypes.RegisterProposalTypeCodec(&amp;UpdateAdminProposal{}, fmt.Sprintf("comdex/asset/%s", ProposalTypeUpdateAdmin))
}</span>

var (
        _ govtypes.Content = (*UpdateAdminProposal)(nil)
)

func (m *UpdateAdminProposal) GetTitle() string       <span class="cov0" title="0">{ return m.Title }</span>
func (m *UpdateAdminProposal) GetDescription() string <span class="cov0" title="0">{ return m.Description }</span>
func (m *UpdateAdminProposal) ProposalRoute() string  <span class="cov0" title="0">{ return RouterKey }</span>
func (m *UpdateAdminProposal) ProposalType() string   <span class="cov0" title="0">{ return ProposalTypeUpdateAdmin }</span>

func (m *UpdateAdminProposal) ValidateBasic() error <span class="cov0" title="0">{
        if err := govtypes.ValidateAbstract(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if m.Address == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("address cannot be empty")
        }</span>
        <span class="cov0" title="0">if _, err := sdk.AccAddressFromBech32(m.Address); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "invalid address %s", m.Address)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/asset/v1beta1/gov.proto

package types

import (
        fmt "fmt"
        _ "github.com/gogo/protobuf/gogoproto"
        proto "github.com/gogo/protobuf/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type UpdateAdminProposal struct {
        Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty" yaml:"title"`
        Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
        Address     string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty" yaml:"address"`
}

func (m *UpdateAdminProposal) Reset()         <span class="cov0" title="0">{ *m = UpdateAdminProposal{} }</span>
func (m *UpdateAdminProposal) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UpdateAdminProposal) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UpdateAdminProposal) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_31c5aab0360b917f, []int{0}
}</span>
func (m *UpdateAdminProposal) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *UpdateAdminProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_UpdateAdminProposal.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *UpdateAdminProposal) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UpdateAdminProposal.Merge(m, src)
}</span>
func (m *UpdateAdminProposal) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *UpdateAdminProposal) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UpdateAdminProposal.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UpdateAdminProposal proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*UpdateAdminProposal)(nil), "comdex.asset.v1beta1.UpdateAdminProposal")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("comdex/asset/v1beta1/gov.proto", fileDescriptor_31c5aab0360b917f) }</span>

var fileDescriptor_31c5aab0360b917f = []byte{
        // 271 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x4c, 0x90, 0xb1, 0x4a, 0xc4, 0x30,
        0x1c, 0x87, 0x1b, 0x45, 0xc5, 0x2a, 0x22, 0xf1, 0x90, 0xe2, 0x90, 0x4a, 0x06, 0x71, 0xd0, 0x86,
        0xc3, 0x45, 0xdc, 0xbc, 0x27, 0xd0, 0x82, 0x8b, 0x5b, 0xda, 0xe4, 0x6a, 0xa0, 0xbd, 0x7f, 0x68,
        0xe2, 0xe1, 0xbd, 0x85, 0x2f, 0x21, 0xf8, 0x28, 0x37, 0xde, 0xe8, 0x54, 0xb4, 0x7d, 0x83, 0x3e,
        0x81, 0x5c, 0xd2, 0x83, 0xdb, 0x92, 0xff, 0xf7, 0xfd, 0x96, 0x2f, 0x24, 0x39, 0x54, 0x42, 0x7e,
        0x30, 0x6e, 0x8c, 0xb4, 0x6c, 0x3e, 0xce, 0xa4, 0xe5, 0x63, 0x56, 0xc0, 0x3c, 0xd1, 0x35, 0x58,
        0xc0, 0x23, 0xcf, 0x13, 0xc7, 0x93, 0x81, 0x5f, 0x8c, 0x0a, 0x28, 0xc0, 0x09, 0x6c, 0xfd, 0xf2,
        0x2e, 0xfd, 0x42, 0xe1, 0xd9, 0x8b, 0x16, 0xdc, 0xca, 0x47, 0x51, 0xa9, 0xd9, 0x53, 0x0d, 0x1a,
        0x0c, 0x2f, 0xf1, 0x55, 0xb8, 0x67, 0x95, 0x2d, 0x65, 0x84, 0x2e, 0xd1, 0xf5, 0xe1, 0xe4, 0xb4,
        0x6f, 0xe2, 0xe3, 0x05, 0xaf, 0xca, 0x07, 0xea, 0xce, 0x34, 0xf5, 0x18, 0xdf, 0x87, 0x47, 0x42,
        0x9a, 0xbc, 0x56, 0xda, 0x2a, 0x98, 0x45, 0x3b, 0xce, 0x3e, 0xef, 0x9b, 0x18, 0x7b, 0x7b, 0x0b,
        0xd2, 0x74, 0x5b, 0xc5, 0x37, 0xe1, 0x01, 0x17, 0xa2, 0x96, 0xc6, 0x44, 0xbb, 0x6e, 0x85, 0xfb,
        0x26, 0x3e, 0xf1, 0xab, 0x01, 0xd0, 0x74, 0xa3, 0x4c, 0x9e, 0x97, 0x7f, 0x24, 0xf8, 0x6e, 0x49,
        0xb0, 0x6c, 0x09, 0x5a, 0xb5, 0x04, 0xfd, 0xb6, 0x04, 0x7d, 0x76, 0x24, 0x58, 0x75, 0x24, 0xf8,
        0xe9, 0x48, 0xf0, 0xca, 0x0a, 0x65, 0xdf, 0xde, 0xb3, 0x24, 0x87, 0x8a, 0xf9, 0x00, 0xb7, 0x30,
        0x9d, 0xaa, 0x5c, 0xf1, 0x72, 0xf8, 0xb3, 0x4d, 0x32, 0xbb, 0xd0, 0xd2, 0x64, 0xfb, 0xae, 0xc0,
        0xdd, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd3, 0x49, 0x03, 0x4a, 0x4f, 0x01, 0x00, 0x00,
}

func (m *UpdateAdminProposal) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *UpdateAdminProposal) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *UpdateAdminProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Address) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Address)
                copy(dAtA[i:], m.Address)
                i = encodeVarintGov(dAtA, i, uint64(len(m.Address)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.Description) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Description)
                copy(dAtA[i:], m.Description)
                i = encodeVarintGov(dAtA, i, uint64(len(m.Description)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Title) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Title)
                copy(dAtA[i:], m.Title)
                i = encodeVarintGov(dAtA, i, uint64(len(m.Title)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintGov(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovGov(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *UpdateAdminProposal) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Title)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovGov(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Description)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovGov(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Address)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovGov(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovGov(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozGov(x uint64) (n int) <span class="cov0" title="0">{
        return sovGov(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *UpdateAdminProposal) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowGov
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: UpdateAdminProposal: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: UpdateAdminProposal: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Title = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Description = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Address = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipGov(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipGov(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowGov
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupGov
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthGov
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthGov        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowGov          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupGov = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file8" style="display: none">package types

import (
        sdk "github.com/cosmos/cosmos-sdk/types"
)

const (
        ModuleName     = "asset"
        ParamsSubspace = ModuleName
        QuerierRoute   = ModuleName
        RouterKey      = ModuleName
        StoreKey       = ModuleName
)

var (
        AssetIDKey    = []byte{0x01}
        PairIDKey     = []byte{0x03}

        AssetKeyPrefix    = []byte{0x11}
        PairKeyPrefix     = []byte{0x14}

        AssetForDenomKeyPrefix  = []byte{0x21}
)

func AssetKey(id uint64) []byte <span class="cov8" title="1">{
        return append(AssetKeyPrefix, sdk.Uint64ToBigEndian(id)...)
}</span>



func AssetForDenomKey(denom string) []byte <span class="cov0" title="0">{
        return append(AssetForDenomKeyPrefix, []byte(denom)...)
}</span>

func PairKey(id uint64) []byte <span class="cov8" title="1">{
        return append(PairKeyPrefix, sdk.Uint64ToBigEndian(id)...)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package types

import (
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/errors"
)

var (
        _ sdk.Msg = (*MsgAddAssetRequest)(nil)
        _ sdk.Msg = (*MsgUpdateAssetRequest)(nil)
        _ sdk.Msg = (*MsgAddPairRequest)(nil)
        _ sdk.Msg = (*MsgUpdatePairRequest)(nil)
)

func NewMsgAddPairRequest(from sdk.AccAddress, assetIn, assetOut uint64, liquidationRatio sdk.Dec) *MsgAddPairRequest <span class="cov8" title="1">{
        return &amp;MsgAddPairRequest{
                From:             from.String(),
                AssetIn:          assetIn,
                AssetOut:         assetOut,
                LiquidationRatio: liquidationRatio,
        }
}</span>

func (m *MsgAddPairRequest) ValidateBasic() error <span class="cov8" title="1">{
        if m.From == "" </span><span class="cov8" title="1">{
                return errors.Wrap(ErrorInvalidFrom, "from cannot be empty")
        }</span>
        <span class="cov8" title="1">if _, err := sdk.AccAddressFromBech32(m.From); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidFrom, "%s", err)
        }</span>
        <span class="cov8" title="1">if m.AssetIn == 0 </span><span class="cov8" title="1">{
                return errors.Wrap(ErrorInvalidID, "asset_in cannot be zero")
        }</span>
        <span class="cov8" title="1">if m.AssetOut == 0 </span><span class="cov8" title="1">{
                return errors.Wrap(ErrorInvalidID, "asset_out cannot be zero")
        }</span>
        <span class="cov8" title="1">if m.LiquidationRatio.IsNil() </span><span class="cov8" title="1">{
                return errors.Wrap(ErrorInvalidLiquidationRatio, "liquidation_ratio cannot be nil")
        }</span>
        <span class="cov8" title="1">if m.LiquidationRatio.IsNegative() </span><span class="cov8" title="1">{
                return errors.Wrap(ErrorInvalidLiquidationRatio, "liquidation_ratio cannot be negative")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (m *MsgAddPairRequest) GetSigners() []sdk.AccAddress <span class="cov8" title="1">{
        from, err := sdk.AccAddressFromBech32(m.From)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return []sdk.AccAddress{from}</span>
}

func NewMsgUpdatePairRequest(from sdk.AccAddress, id uint64, liquidationRatio sdk.Dec) *MsgUpdatePairRequest <span class="cov8" title="1">{
        return &amp;MsgUpdatePairRequest{
                From:             from.String(),
                Id:               id,
                LiquidationRatio: liquidationRatio,
        }
}</span>

func (m *MsgUpdatePairRequest) ValidateBasic() error <span class="cov8" title="1">{
        if m.From == "" </span><span class="cov8" title="1">{
                return errors.Wrap(ErrorInvalidFrom, "from cannot be empty")
        }</span>
        <span class="cov8" title="1">if _, err := sdk.AccAddressFromBech32(m.From); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidFrom, "%s", err)
        }</span>
        <span class="cov8" title="1">if !m.LiquidationRatio.IsNil() </span><span class="cov8" title="1">{
                if m.LiquidationRatio.IsNegative() </span><span class="cov8" title="1">{
                        return errors.Wrap(ErrorInvalidLiquidationRatio, "liquidation_ratio cannot be negative")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (m *MsgUpdatePairRequest) GetSigners() []sdk.AccAddress <span class="cov8" title="1">{
        from, err := sdk.AccAddressFromBech32(m.From)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return []sdk.AccAddress{from}</span>
}

func NewMsgAddAssetRequest(from sdk.AccAddress, name, denom string, decimals int64) *MsgAddAssetRequest <span class="cov8" title="1">{
        return &amp;MsgAddAssetRequest{
                From:     from.String(),
                Name:     name,
                Denom:    denom,
                Decimals: decimals,
        }
}</span>

func (m *MsgAddAssetRequest) ValidateBasic() error <span class="cov8" title="1">{
        if m.From == "" </span><span class="cov8" title="1">{
                return errors.Wrap(ErrorInvalidFrom, "from cannot be empty")
        }</span>
        <span class="cov8" title="1">if _, err := sdk.AccAddressFromBech32(m.From); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidFrom, "%s", err)
        }</span>
        <span class="cov8" title="1">if m.Name == "" </span><span class="cov8" title="1">{
                return errors.Wrap(ErrorInvalidName, "name cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; MaxAssetNameLength </span><span class="cov8" title="1">{
                return errors.Wrapf(ErrorInvalidName, "name length cannot be greater than %d", MaxAssetNameLength)
        }</span>
        <span class="cov8" title="1">if m.Denom == "" </span><span class="cov8" title="1">{
                return errors.Wrapf(ErrorInvalidDenom, "denom cannot be empty")
        }</span>
        <span class="cov8" title="1">if err := sdk.ValidateDenom(m.Denom); err != nil </span><span class="cov8" title="1">{
                return errors.Wrapf(ErrorInvalidDenom, "%s", err)
        }</span>
        <span class="cov8" title="1">if m.Decimals &lt; 0 </span><span class="cov8" title="1">{
                return errors.Wrapf(ErrorInvalidDecimals, "decimals cannot be less than zero")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (m *MsgAddAssetRequest) GetSigners() []sdk.AccAddress <span class="cov8" title="1">{
        from, err := sdk.AccAddressFromBech32(m.From)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return []sdk.AccAddress{from}</span>
}

func NewMsgUpdateAssetRequest(from sdk.AccAddress, id uint64, name, denom string, decimals int64) *MsgUpdateAssetRequest <span class="cov8" title="1">{
        return &amp;MsgUpdateAssetRequest{
                From:     from.String(),
                Id:       id,
                Name:     name,
                Denom:    denom,
                Decimals: decimals,
        }
}</span>

func (m *MsgUpdateAssetRequest) ValidateBasic() error <span class="cov8" title="1">{
        if m.From == "" </span><span class="cov8" title="1">{
                return errors.Wrap(ErrorInvalidFrom, "from cannot be empty")
        }</span>
        <span class="cov8" title="1">if _, err := sdk.AccAddressFromBech32(m.From); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidFrom, "%s", err)
        }</span>
        <span class="cov8" title="1">if m.Name != "" </span><span class="cov8" title="1">{
                if len(m.Name) &gt; MaxAssetNameLength </span><span class="cov8" title="1">{
                        return errors.Wrapf(ErrorInvalidName, "name length cannot be greater than %d", MaxAssetNameLength)
                }</span>
        }
        <span class="cov8" title="1">if m.Denom != "" </span><span class="cov8" title="1">{
                if err := sdk.ValidateDenom(m.Denom); err != nil </span><span class="cov8" title="1">{
                        return errors.Wrapf(ErrorInvalidDenom, "%s", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (m *MsgUpdateAssetRequest) GetSigners() []sdk.AccAddress <span class="cov8" title="1">{
        from, err := sdk.AccAddressFromBech32(m.From)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return []sdk.AccAddress{from}</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/asset/v1beta1/msg.proto

package types

import (
        context "context"
        fmt "fmt"
        github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
        _ "github.com/gogo/protobuf/gogoproto"
        grpc1 "github.com/gogo/protobuf/grpc"
        proto "github.com/gogo/protobuf/proto"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MsgAddAssetRequest struct {
        From     string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" yaml:"from"`
        Name     string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" yaml:"name"`
        Denom    string `protobuf:"bytes,3,opt,name=denom,proto3" json:"denom,omitempty" yaml:"denom"`
        Decimals int64  `protobuf:"varint,4,opt,name=decimals,proto3" json:"decimals,omitempty" yaml:"decimals"`
}

func (m *MsgAddAssetRequest) Reset()         <span class="cov0" title="0">{ *m = MsgAddAssetRequest{} }</span>
func (m *MsgAddAssetRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgAddAssetRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgAddAssetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{0}
}</span>
func (m *MsgAddAssetRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgAddAssetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgAddAssetRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgAddAssetRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddAssetRequest.Merge(m, src)
}</span>
func (m *MsgAddAssetRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgAddAssetRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddAssetRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgAddAssetRequest proto.InternalMessageInfo

type MsgAddAssetResponse struct {
}

func (m *MsgAddAssetResponse) Reset()         <span class="cov0" title="0">{ *m = MsgAddAssetResponse{} }</span>
func (m *MsgAddAssetResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgAddAssetResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgAddAssetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{1}
}</span>
func (m *MsgAddAssetResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgAddAssetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgAddAssetResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgAddAssetResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddAssetResponse.Merge(m, src)
}</span>
func (m *MsgAddAssetResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgAddAssetResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddAssetResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgAddAssetResponse proto.InternalMessageInfo

type MsgUpdateAssetRequest struct {
        From     string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" yaml:"from"`
        Id       uint64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
        Name     string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty" yaml:"name"`
        Denom    string `protobuf:"bytes,4,opt,name=denom,proto3" json:"denom,omitempty" yaml:"denom"`
        Decimals int64  `protobuf:"varint,5,opt,name=decimals,proto3" json:"decimals,omitempty" yaml:"decimals"`
}

func (m *MsgUpdateAssetRequest) Reset()         <span class="cov0" title="0">{ *m = MsgUpdateAssetRequest{} }</span>
func (m *MsgUpdateAssetRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUpdateAssetRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUpdateAssetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{2}
}</span>
func (m *MsgUpdateAssetRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdateAssetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdateAssetRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdateAssetRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateAssetRequest.Merge(m, src)
}</span>
func (m *MsgUpdateAssetRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdateAssetRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateAssetRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdateAssetRequest proto.InternalMessageInfo

type MsgUpdateAssetResponse struct {
}

func (m *MsgUpdateAssetResponse) Reset()         <span class="cov0" title="0">{ *m = MsgUpdateAssetResponse{} }</span>
func (m *MsgUpdateAssetResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUpdateAssetResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUpdateAssetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{3}
}</span>
func (m *MsgUpdateAssetResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdateAssetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdateAssetResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdateAssetResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateAssetResponse.Merge(m, src)
}</span>
func (m *MsgUpdateAssetResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdateAssetResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateAssetResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdateAssetResponse proto.InternalMessageInfo

type MsgAddPairRequest struct {
        From             string                                 `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" yaml:"from"`
        AssetIn          uint64                                 `protobuf:"varint,2,opt,name=asset_in,json=assetIn,proto3" json:"asset_in,omitempty" yaml:"asset_in"`
        AssetOut         uint64                                 `protobuf:"varint,3,opt,name=asset_out,json=assetOut,proto3" json:"asset_out,omitempty" yaml:"asset_out"`
        LiquidationRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=liquidation_ratio,json=liquidationRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"liquidation_ratio" yaml:"liquidation_ratio"`
}

func (m *MsgAddPairRequest) Reset()         <span class="cov0" title="0">{ *m = MsgAddPairRequest{} }</span>
func (m *MsgAddPairRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgAddPairRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgAddPairRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{4}
}</span>
func (m *MsgAddPairRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgAddPairRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgAddPairRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgAddPairRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddPairRequest.Merge(m, src)
}</span>
func (m *MsgAddPairRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgAddPairRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddPairRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgAddPairRequest proto.InternalMessageInfo

type MsgAddPairResponse struct {
}

func (m *MsgAddPairResponse) Reset()         <span class="cov0" title="0">{ *m = MsgAddPairResponse{} }</span>
func (m *MsgAddPairResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgAddPairResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgAddPairResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{5}
}</span>
func (m *MsgAddPairResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgAddPairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgAddPairResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgAddPairResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddPairResponse.Merge(m, src)
}</span>
func (m *MsgAddPairResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgAddPairResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddPairResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgAddPairResponse proto.InternalMessageInfo

type MsgUpdatePairRequest struct {
        From             string                                 `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" yaml:"from"`
        Id               uint64                                 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
        LiquidationRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=liquidation_ratio,json=liquidationRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"liquidation_ratio" yaml:"liquidation_ratio"`
}

func (m *MsgUpdatePairRequest) Reset()         <span class="cov0" title="0">{ *m = MsgUpdatePairRequest{} }</span>
func (m *MsgUpdatePairRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUpdatePairRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUpdatePairRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{6}
}</span>
func (m *MsgUpdatePairRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdatePairRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdatePairRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdatePairRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdatePairRequest.Merge(m, src)
}</span>
func (m *MsgUpdatePairRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdatePairRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdatePairRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdatePairRequest proto.InternalMessageInfo

type MsgUpdatePairResponse struct {
}

func (m *MsgUpdatePairResponse) Reset()         <span class="cov0" title="0">{ *m = MsgUpdatePairResponse{} }</span>
func (m *MsgUpdatePairResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUpdatePairResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUpdatePairResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{7}
}</span>
func (m *MsgUpdatePairResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdatePairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdatePairResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdatePairResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdatePairResponse.Merge(m, src)
}</span>
func (m *MsgUpdatePairResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdatePairResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdatePairResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdatePairResponse proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*MsgAddAssetRequest)(nil), "comdex.asset.v1beta1.MsgAddAssetRequest")
        proto.RegisterType((*MsgAddAssetResponse)(nil), "comdex.asset.v1beta1.MsgAddAssetResponse")
        proto.RegisterType((*MsgUpdateAssetRequest)(nil), "comdex.asset.v1beta1.MsgUpdateAssetRequest")
        proto.RegisterType((*MsgUpdateAssetResponse)(nil), "comdex.asset.v1beta1.MsgUpdateAssetResponse")
        proto.RegisterType((*MsgAddPairRequest)(nil), "comdex.asset.v1beta1.MsgAddPairRequest")
        proto.RegisterType((*MsgAddPairResponse)(nil), "comdex.asset.v1beta1.MsgAddPairResponse")
        proto.RegisterType((*MsgUpdatePairRequest)(nil), "comdex.asset.v1beta1.MsgUpdatePairRequest")
        proto.RegisterType((*MsgUpdatePairResponse)(nil), "comdex.asset.v1beta1.MsgUpdatePairResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("comdex/asset/v1beta1/msg.proto", fileDescriptor_71dc8806a9f74763) }</span>

var fileDescriptor_71dc8806a9f74763 = []byte{
        // 583 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x94, 0xc1, 0x6e, 0xd3, 0x30,
        0x18, 0xc7, 0x93, 0xb6, 0x83, 0xcd, 0x83, 0xad, 0xf3, 0x3a, 0x88, 0x7a, 0x48, 0x26, 0x23, 0x8d,
        0xc2, 0x58, 0xa2, 0xc2, 0x8d, 0xdb, 0x2a, 0x2e, 0x20, 0x55, 0x40, 0x10, 0x17, 0x2e, 0x55, 0x9a,
        0xb8, 0x99, 0xb5, 0x26, 0xee, 0x6a, 0x67, 0xb0, 0xb7, 0xe0, 0xc0, 0x43, 0xec, 0x0d, 0x78, 0x01,
        0x0e, 0x15, 0xa7, 0x1d, 0x11, 0x87, 0x08, 0xda, 0x37, 0xc8, 0x13, 0xa0, 0xd8, 0x69, 0x95, 0xb6,
        0x83, 0xa5, 0x17, 0x4e, 0x49, 0xbe, 0xff, 0x3f, 0xfe, 0xbe, 0xdf, 0xe7, 0xcf, 0x06, 0xba, 0x4b,
        0x03, 0x0f, 0x7f, 0xb2, 0x1c, 0xc6, 0x30, 0xb7, 0xce, 0x9b, 0x5d, 0xcc, 0x9d, 0xa6, 0x15, 0x30,
        0xdf, 0x1c, 0x0c, 0x29, 0xa7, 0xb0, 0x26, 0x75, 0x53, 0xe8, 0x66, 0xa6, 0xd7, 0x6b, 0x3e, 0xf5,
        0xa9, 0x30, 0x58, 0xe9, 0x9b, 0xf4, 0xa2, 0xaf, 0x2a, 0x80, 0x6d, 0xe6, 0x1f, 0x7b, 0xde, 0x71,
        0xea, 0xb6, 0xf1, 0x59, 0x84, 0x19, 0x87, 0x0f, 0x40, 0xa5, 0x37, 0xa4, 0x81, 0xa6, 0xee, 0xab,
        0x8d, 0x8d, 0xd6, 0x76, 0x12, 0x1b, 0x9b, 0x17, 0x4e, 0xd0, 0x7f, 0x8e, 0xd2, 0x28, 0xb2, 0x85,
        0x98, 0x9a, 0x42, 0x27, 0xc0, 0x5a, 0x69, 0xd1, 0x94, 0x46, 0x91, 0x2d, 0x44, 0x78, 0x00, 0xd6,
        0x3c, 0x1c, 0xd2, 0x40, 0x2b, 0x0b, 0x57, 0x35, 0x89, 0x8d, 0x3b, 0xd2, 0x25, 0xc2, 0xc8, 0x96,
        0x32, 0xb4, 0xc0, 0xba, 0x87, 0x5d, 0x12, 0x38, 0x7d, 0xa6, 0x55, 0xf6, 0xd5, 0x46, 0xb9, 0xb5,
        0x9b, 0xc4, 0xc6, 0xf6, 0xd4, 0x2a, 0x15, 0x64, 0xcf, 0x4c, 0x68, 0x0f, 0xec, 0xce, 0x15, 0xce,
        0x06, 0x34, 0x64, 0x18, 0x7d, 0x57, 0xc1, 0x5e, 0x9b, 0xf9, 0xef, 0x07, 0x9e, 0xc3, 0xf1, 0xea,
        0x4c, 0x5b, 0xa0, 0x44, 0x3c, 0x41, 0x54, 0xb1, 0x4b, 0xc4, 0x9b, 0x31, 0x96, 0x0b, 0x31, 0x56,
        0x8a, 0x33, 0xae, 0x15, 0x61, 0xd4, 0xc0, 0xbd, 0x45, 0x96, 0x0c, 0xf3, 0x4b, 0x09, 0xec, 0x48,
        0xfc, 0x37, 0x0e, 0x19, 0xae, 0x84, 0x68, 0x82, 0x75, 0x31, 0x19, 0x1d, 0x12, 0x4a, 0xd0, 0x7c,
        0x15, 0x53, 0x05, 0xd9, 0xb7, 0xc5, 0xeb, 0xcb, 0x10, 0x36, 0xc1, 0x86, 0x8c, 0xd2, 0x88, 0x8b,
        0x3e, 0x54, 0x5a, 0xb5, 0x24, 0x36, 0xaa, 0xf9, 0x1f, 0x68, 0xc4, 0x91, 0x2d, 0x97, 0x7d, 0x1d,
        0x71, 0xf8, 0x11, 0xec, 0xf4, 0xc9, 0x59, 0x44, 0x3c, 0x87, 0x13, 0x1a, 0x76, 0x86, 0xe9, 0x23,
        0x6b, 0xce, 0xab, 0x51, 0x6c, 0x28, 0x3f, 0x63, 0xe3, 0xc0, 0x27, 0xfc, 0x24, 0xea, 0x9a, 0x2e,
        0x0d, 0x2c, 0x97, 0xb2, 0x80, 0xb2, 0xec, 0x71, 0xc4, 0xbc, 0x53, 0x8b, 0x5f, 0x0c, 0x30, 0x33,
        0x5f, 0x60, 0x37, 0x89, 0x0d, 0x4d, 0x26, 0x5a, 0x5a, 0x10, 0xd9, 0xd5, 0x5c, 0xcc, 0x16, 0xa1,
        0xda, 0x74, 0x9a, 0x65, 0x57, 0xb2, 0x66, 0x7d, 0x53, 0x41, 0x6d, 0xd6, 0xc7, 0x95, 0xfb, 0xb5,
        0x38, 0x12, 0xd7, 0xc2, 0x95, 0xff, 0x03, 0xdc, 0xfd, 0xdc, 0x64, 0xe7, 0xf9, 0x9e, 0x5e, 0x96,
        0x01, 0x68, 0x33, 0xff, 0x1d, 0x1e, 0x9e, 0x13, 0x17, 0xc3, 0x2e, 0xd8, 0xcc, 0x9d, 0x0c, 0xd8,
        0x30, 0xaf, 0xbb, 0x0f, 0xcc, 0xe5, 0x53, 0x5f, 0x7f, 0x54, 0xc0, 0x29, 0x53, 0xc2, 0x53, 0xb0,
        0x35, 0x3f, 0x99, 0xf0, 0xf0, 0xaf, 0x3f, 0x2f, 0x9f, 0xc5, 0xfa, 0x93, 0x62, 0xe6, 0x2c, 0x59,
        0x47, 0xe0, 0x65, 0xbb, 0x0a, 0x1f, 0xfe, 0xab, 0xca, 0xdc, 0xee, 0xd6, 0x1b, 0x37, 0x1b, 0xb3,
        0x04, 0x27, 0xe0, 0xee, 0x5c, 0x67, 0xe1, 0xe3, 0x1b, 0xea, 0xcb, 0xa7, 0x39, 0x2c, 0xe4, 0x95,
        0x99, 0x5a, 0x6f, 0x47, 0xbf, 0x75, 0xe5, 0x72, 0xac, 0x2b, 0xa3, 0xb1, 0xae, 0x5e, 0x8d, 0x75,
        0xf5, 0xd7, 0x58, 0x57, 0x3f, 0x4f, 0x74, 0xe5, 0x6a, 0xa2, 0x2b, 0x3f, 0x26, 0xba, 0xf2, 0xc1,
        0x9a, 0x9b, 0x9d, 0x74, 0xe1, 0x23, 0xda, 0xeb, 0x11, 0x97, 0x38, 0xfd, 0xec, 0xdb, 0x9a, 0x5e,
        0xfd, 0x62, 0x90, 0xba, 0xb7, 0xc4, 0x4d, 0xfe, 0xec, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xbc,
        0x4c, 0xe8, 0xc1, 0x17, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgServiceClient is the client API for MsgService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgServiceClient interface {
        MsgAddAsset(ctx context.Context, in *MsgAddAssetRequest, opts ...grpc.CallOption) (*MsgAddAssetResponse, error)
        MsgUpdateAsset(ctx context.Context, in *MsgUpdateAssetRequest, opts ...grpc.CallOption) (*MsgUpdateAssetResponse, error)
        MsgAddPair(ctx context.Context, in *MsgAddPairRequest, opts ...grpc.CallOption) (*MsgAddPairResponse, error)
        MsgUpdatePair(ctx context.Context, in *MsgUpdatePairRequest, opts ...grpc.CallOption) (*MsgUpdatePairResponse, error)
}

type msgServiceClient struct {
        cc grpc1.ClientConn
}

func NewMsgServiceClient(cc grpc1.ClientConn) MsgServiceClient <span class="cov0" title="0">{
        return &amp;msgServiceClient{cc}
}</span>

func (c *msgServiceClient) MsgAddAsset(ctx context.Context, in *MsgAddAssetRequest, opts ...grpc.CallOption) (*MsgAddAssetResponse, error) <span class="cov0" title="0">{
        out := new(MsgAddAssetResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.MsgService/MsgAddAsset", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgServiceClient) MsgUpdateAsset(ctx context.Context, in *MsgUpdateAssetRequest, opts ...grpc.CallOption) (*MsgUpdateAssetResponse, error) <span class="cov0" title="0">{
        out := new(MsgUpdateAssetResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.MsgService/MsgUpdateAsset", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgServiceClient) MsgAddPair(ctx context.Context, in *MsgAddPairRequest, opts ...grpc.CallOption) (*MsgAddPairResponse, error) <span class="cov0" title="0">{
        out := new(MsgAddPairResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.MsgService/MsgAddPair", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgServiceClient) MsgUpdatePair(ctx context.Context, in *MsgUpdatePairRequest, opts ...grpc.CallOption) (*MsgUpdatePairResponse, error) <span class="cov0" title="0">{
        out := new(MsgUpdatePairResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.MsgService/MsgUpdatePair", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// MsgServiceServer is the server API for MsgService service.
type MsgServiceServer interface {
        MsgAddAsset(context.Context, *MsgAddAssetRequest) (*MsgAddAssetResponse, error)
        MsgUpdateAsset(context.Context, *MsgUpdateAssetRequest) (*MsgUpdateAssetResponse, error)
        MsgAddPair(context.Context, *MsgAddPairRequest) (*MsgAddPairResponse, error)
        MsgUpdatePair(context.Context, *MsgUpdatePairRequest) (*MsgUpdatePairResponse, error)
}

// UnimplementedMsgServiceServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServiceServer struct {
}

func (*UnimplementedMsgServiceServer) MsgAddAsset(ctx context.Context, req *MsgAddAssetRequest) (*MsgAddAssetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MsgAddAsset not implemented")
}</span>
func (*UnimplementedMsgServiceServer) MsgUpdateAsset(ctx context.Context, req *MsgUpdateAssetRequest) (*MsgUpdateAssetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MsgUpdateAsset not implemented")
}</span>
func (*UnimplementedMsgServiceServer) MsgAddPair(ctx context.Context, req *MsgAddPairRequest) (*MsgAddPairResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MsgAddPair not implemented")
}</span>
func (*UnimplementedMsgServiceServer) MsgUpdatePair(ctx context.Context, req *MsgUpdatePairRequest) (*MsgUpdatePairResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MsgUpdatePair not implemented")
}</span>

func RegisterMsgServiceServer(s grpc1.Server, srv MsgServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_MsgService_serviceDesc, srv)
}</span>

func _MsgService_MsgAddAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgAddAssetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgAddAsset(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.MsgService/MsgAddAsset",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgAddAsset(ctx, req.(*MsgAddAssetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MsgService_MsgUpdateAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgUpdateAssetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgUpdateAsset(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.MsgService/MsgUpdateAsset",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgUpdateAsset(ctx, req.(*MsgUpdateAssetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MsgService_MsgAddPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgAddPairRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgAddPair(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.MsgService/MsgAddPair",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgAddPair(ctx, req.(*MsgAddPairRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MsgService_MsgUpdatePair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgUpdatePairRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgUpdatePair(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.MsgService/MsgUpdatePair",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgUpdatePair(ctx, req.(*MsgUpdatePairRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _MsgService_serviceDesc = grpc.ServiceDesc{
        ServiceName: "comdex.asset.v1beta1.MsgService",
        HandlerType: (*MsgServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "MsgAddAsset",
                        Handler:    _MsgService_MsgAddAsset_Handler,
                },
                {
                        MethodName: "MsgUpdateAsset",
                        Handler:    _MsgService_MsgUpdateAsset_Handler,
                },
                {
                        MethodName: "MsgAddPair",
                        Handler:    _MsgService_MsgAddPair_Handler,
                },
                {
                        MethodName: "MsgUpdatePair",
                        Handler:    _MsgService_MsgUpdatePair_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "comdex/asset/v1beta1/msg.proto",
}

func (m *MsgAddAssetRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgAddAssetRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgAddAssetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Decimals != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMsg(dAtA, i, uint64(m.Decimals))
                i--
                dAtA[i] = 0x20
        }</span>
        <span class="cov0" title="0">if len(m.Denom) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Denom)
                copy(dAtA[i:], m.Denom)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.Denom)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.Name) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.From) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.From)
                copy(dAtA[i:], m.From)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.From)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgAddAssetResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgAddAssetResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgAddAssetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgUpdateAssetRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdateAssetRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdateAssetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Decimals != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMsg(dAtA, i, uint64(m.Decimals))
                i--
                dAtA[i] = 0x28
        }</span>
        <span class="cov0" title="0">if len(m.Denom) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Denom)
                copy(dAtA[i:], m.Denom)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.Denom)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov0" title="0">if len(m.Name) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMsg(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.From) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.From)
                copy(dAtA[i:], m.From)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.From)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgUpdateAssetResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdateAssetResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdateAssetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgAddPairRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgAddPairRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgAddPairRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size := m.LiquidationRatio.Size()
                i -= size
                if _, err := m.LiquidationRatio.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintMsg(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x22
        if m.AssetOut != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMsg(dAtA, i, uint64(m.AssetOut))
                i--
                dAtA[i] = 0x18
        }</span>
        <span class="cov0" title="0">if m.AssetIn != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMsg(dAtA, i, uint64(m.AssetIn))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.From) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.From)
                copy(dAtA[i:], m.From)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.From)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgAddPairResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgAddPairResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgAddPairResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgUpdatePairRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdatePairRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdatePairRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size := m.LiquidationRatio.Size()
                i -= size
                if _, err := m.LiquidationRatio.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintMsg(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x1a
        if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMsg(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.From) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.From)
                copy(dAtA[i:], m.From)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.From)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgUpdatePairResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdatePairResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdatePairResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func encodeVarintMsg(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovMsg(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *MsgAddAssetRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.From)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Name)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Denom)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Decimals != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMsg(uint64(m.Decimals))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgAddAssetResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgUpdateAssetRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.From)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMsg(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">l = len(m.Name)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Denom)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Decimals != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMsg(uint64(m.Decimals))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgUpdateAssetResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgAddPairRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.From)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.AssetIn != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMsg(uint64(m.AssetIn))
        }</span>
        <span class="cov0" title="0">if m.AssetOut != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMsg(uint64(m.AssetOut))
        }</span>
        <span class="cov0" title="0">l = m.LiquidationRatio.Size()
        n += 1 + l + sovMsg(uint64(l))
        return n</span>
}

func (m *MsgAddPairResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgUpdatePairRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.From)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMsg(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">l = m.LiquidationRatio.Size()
        n += 1 + l + sovMsg(uint64(l))
        return n</span>
}

func (m *MsgUpdatePairResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func sovMsg(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozMsg(x uint64) (n int) <span class="cov0" title="0">{
        return sovMsg(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *MsgAddAssetRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddAssetRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddAssetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.From = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Denom = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Decimals = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Decimals |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgAddAssetResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddAssetResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddAssetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUpdateAssetRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateAssetRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateAssetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.From = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Denom = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Decimals = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Decimals |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUpdateAssetResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateAssetResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateAssetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgAddPairRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddPairRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddPairRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.From = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AssetIn", wireType)
                        }</span>
                        <span class="cov0" title="0">m.AssetIn = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.AssetIn |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AssetOut", wireType)
                        }</span>
                        <span class="cov0" title="0">m.AssetOut = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.AssetOut |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field LiquidationRatio", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.LiquidationRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgAddPairResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddPairResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddPairResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUpdatePairRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdatePairRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdatePairRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.From = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field LiquidationRatio", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.LiquidationRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUpdatePairResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdatePairResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdatePairResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipMsg(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupMsg
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthMsg
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthMsg        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowMsg          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupMsg = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file11" style="display: none">package types

import (
        "fmt"
)

func (m *Pair) Validate() error <span class="cov8" title="1">{
        if m.Id == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("id cannot be zero")
        }</span>
        <span class="cov8" title="1">if m.AssetIn == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("asset_in cannot be zero")
        }</span>
        <span class="cov8" title="1">if m.AssetOut == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("asset_out cannot be zero")
        }</span>
        <span class="cov8" title="1">if m.LiquidationRatio.IsNil() </span><span class="cov8" title="1">{
                return fmt.Errorf("liquidation_ratio cannot be nil")
        }</span>
        <span class="cov8" title="1">if m.LiquidationRatio.IsNegative() </span><span class="cov8" title="1">{
                return fmt.Errorf("liquidation_ratio cannot be negative")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/asset/v1beta1/pair.proto

package types

import (
        fmt "fmt"
        github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
        _ "github.com/gogo/protobuf/gogoproto"
        proto "github.com/gogo/protobuf/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Pair struct {
        Id               uint64                                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        AssetIn          uint64                                 `protobuf:"varint,2,opt,name=asset_in,json=assetIn,proto3" json:"asset_in,omitempty" yaml:"asset_in"`
        AssetOut         uint64                                 `protobuf:"varint,3,opt,name=asset_out,json=assetOut,proto3" json:"asset_out,omitempty" yaml:"asset_out"`
        LiquidationRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=liquidation_ratio,json=liquidationRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"liquidation_ratio" yaml:"liquidation_ratio"`
}

func (m *Pair) Reset()         <span class="cov0" title="0">{ *m = Pair{} }</span>
func (m *Pair) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Pair) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Pair) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_65bd24918e5ac160, []int{0}
}</span>
func (m *Pair) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Pair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Pair.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Pair) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Pair.Merge(m, src)
}</span>
func (m *Pair) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Pair) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Pair.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Pair proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Pair)(nil), "comdex.asset.v1beta1.Pair")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("comdex/asset/v1beta1/pair.proto", fileDescriptor_65bd24918e5ac160) }</span>

var fileDescriptor_65bd24918e5ac160 = []byte{
        // 316 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x91, 0xb1, 0x4e, 0xc3, 0x30,
        0x10, 0x86, 0xed, 0x52, 0x01, 0xf5, 0x00, 0x25, 0x74, 0x88, 0x18, 0xec, 0x2a, 0x03, 0xea, 0x52,
        0x5b, 0x15, 0x1b, 0x63, 0xc5, 0x02, 0x0b, 0x90, 0x91, 0xa5, 0x72, 0x93, 0xb4, 0x58, 0x34, 0xbd,
        0x12, 0x3b, 0x40, 0xdf, 0x82, 0xc7, 0xe0, 0x51, 0x3a, 0x76, 0x44, 0x0c, 0x11, 0xa4, 0x6f, 0x90,
        0x27, 0x40, 0x71, 0x52, 0xa9, 0x88, 0xc5, 0x77, 0xfe, 0xfd, 0xfd, 0x77, 0xd6, 0x1d, 0x61, 0x01,
        0xc4, 0x61, 0xf4, 0x26, 0xa4, 0xd6, 0x91, 0x11, 0x2f, 0x83, 0x71, 0x64, 0xe4, 0x40, 0x2c, 0xa4,
        0x4a, 0xf8, 0x22, 0x01, 0x03, 0x4e, 0xa7, 0x02, 0xb8, 0x05, 0x78, 0x0d, 0x9c, 0x75, 0xa6, 0x30,
        0x05, 0x0b, 0x88, 0x32, 0xab, 0x58, 0xaf, 0xc0, 0xa4, 0x79, 0x27, 0x55, 0xe2, 0x1c, 0x91, 0x86,
        0x0a, 0x5d, 0xdc, 0xc5, 0xbd, 0xa6, 0xdf, 0x50, 0xa1, 0xc3, 0xc9, 0xa1, 0xf5, 0x8f, 0xd4, 0xdc,
        0x6d, 0x94, 0xea, 0xf0, 0xb4, 0xc8, 0xd8, 0xf1, 0x52, 0xc6, 0xb3, 0x4b, 0x6f, 0xfb, 0xe2, 0xf9,
        0x07, 0x36, 0xbd, 0x9e, 0x3b, 0x03, 0xd2, 0xaa, 0x54, 0x48, 0x8d, 0xbb, 0x67, 0x0d, 0x9d, 0x22,
        0x63, 0xed, 0x5d, 0x03, 0xa4, 0xc6, 0xf3, 0xab, 0xb2, 0xb7, 0xa9, 0x71, 0x5e, 0xc9, 0xc9, 0x4c,
        0x3d, 0xa7, 0x2a, 0x94, 0x46, 0xc1, 0x7c, 0x94, 0x94, 0xc1, 0x6d, 0x76, 0x71, 0xaf, 0x35, 0xbc,
        0x59, 0x65, 0x0c, 0x7d, 0x65, 0xec, 0x7c, 0xaa, 0xcc, 0x63, 0x3a, 0xe6, 0x01, 0xc4, 0x22, 0x00,
        0x1d, 0x83, 0xae, 0x43, 0x5f, 0x87, 0x4f, 0xc2, 0x2c, 0x17, 0x91, 0xe6, 0x57, 0x51, 0x50, 0x64,
        0xcc, 0xad, 0x1a, 0xfd, 0x2b, 0xe8, 0xf9, 0xed, 0x1d, 0xcd, 0x2f, 0xcf, 0xe1, 0xfd, 0xea, 0x87,
        0xa2, 0x8f, 0x9c, 0xa2, 0x55, 0x4e, 0xf1, 0x3a, 0xa7, 0xf8, 0x3b, 0xa7, 0xf8, 0x7d, 0x43, 0xd1,
        0x7a, 0x43, 0xd1, 0xe7, 0x86, 0xa2, 0x07, 0xf1, 0xa7, 0x6f, 0x39, 0xcd, 0x3e, 0x4c, 0x26, 0x2a,
        0x50, 0x72, 0x56, 0xdf, 0xc5, 0x76, 0x01, 0xf6, 0x13, 0xe3, 0x7d, 0x3b, 0xce, 0x8b, 0xdf, 0x00,
        0x00, 0x00, 0xff, 0xff, 0x20, 0x23, 0xdb, 0x1a, 0x9d, 0x01, 0x00, 0x00,
}

func (m *Pair) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Pair) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Pair) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size := m.LiquidationRatio.Size()
                i -= size
                if _, err := m.LiquidationRatio.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintPair(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x22
        if m.AssetOut != 0 </span><span class="cov0" title="0">{
                i = encodeVarintPair(dAtA, i, uint64(m.AssetOut))
                i--
                dAtA[i] = 0x18
        }</span>
        <span class="cov0" title="0">if m.AssetIn != 0 </span><span class="cov0" title="0">{
                i = encodeVarintPair(dAtA, i, uint64(m.AssetIn))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintPair(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintPair(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovPair(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Pair) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovPair(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">if m.AssetIn != 0 </span><span class="cov0" title="0">{
                n += 1 + sovPair(uint64(m.AssetIn))
        }</span>
        <span class="cov0" title="0">if m.AssetOut != 0 </span><span class="cov0" title="0">{
                n += 1 + sovPair(uint64(m.AssetOut))
        }</span>
        <span class="cov0" title="0">l = m.LiquidationRatio.Size()
        n += 1 + l + sovPair(uint64(l))
        return n</span>
}

func sovPair(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozPair(x uint64) (n int) <span class="cov0" title="0">{
        return sovPair(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Pair) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowPair
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Pair: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Pair: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowPair
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AssetIn", wireType)
                        }</span>
                        <span class="cov0" title="0">m.AssetIn = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowPair
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.AssetIn |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AssetOut", wireType)
                        }</span>
                        <span class="cov0" title="0">m.AssetOut = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowPair
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.AssetOut |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field LiquidationRatio", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowPair
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthPair
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthPair
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.LiquidationRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipPair(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthPair
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipPair(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowPair
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowPair
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowPair
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthPair
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupPair
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthPair
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthPair        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowPair          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupPair = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file13" style="display: none">package types

import (
        "fmt"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/errors"
        paramstypes "github.com/cosmos/cosmos-sdk/x/params/types"
)

const (
        DefaultAdmin = ""
)

var (
        KeyAdmin = []byte("Admin")
)

var (
        _ paramstypes.ParamSet = (*Params)(nil)
)

func NewParams(admin string) Params <span class="cov8" title="1">{
        return Params{
                Admin: admin,
        }
}</span>

func DefaultParams() Params <span class="cov8" title="1">{
        return NewParams(
                DefaultAdmin,
        )
}</span>

func (m *Params) ParamSetPairs() paramstypes.ParamSetPairs <span class="cov0" title="0">{
        return paramstypes.ParamSetPairs{
                paramstypes.NewParamSetPair(
                        KeyAdmin,
                        m.Admin,
                        func(v interface{}) error </span><span class="cov0" title="0">{
                                value, ok := v.(string)
                                if !ok </span><span class="cov0" title="0">{
                                        return fmt.Errorf("invalid parameter type %T", v)
                                }</span>

                                <span class="cov0" title="0">if value == "" </span><span class="cov0" title="0">{
                                        return fmt.Errorf("admin cannot be empty")
                                }</span>
                                <span class="cov0" title="0">if _, err := sdk.AccAddressFromBech32(value); err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrapf(err, "invalid admin %s", value)
                                }</span>

                                <span class="cov0" title="0">return nil</span>
                        },
                ),
        }
}

func (m *Params) Validate() error <span class="cov8" title="1">{
        if m.Admin == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("admin cannot be empty")
        }</span>
        <span class="cov8" title="1">if _, err := sdk.AccAddressFromBech32(m.Admin); err != nil </span><span class="cov8" title="1">{
                return errors.Wrapf(err, "invalid admin %s", m.Admin)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/asset/v1beta1/params.proto

package types

import (
        fmt "fmt"
        _ "github.com/gogo/protobuf/gogoproto"
        proto "github.com/gogo/protobuf/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Params struct {
        Admin string `protobuf:"bytes,1,opt,name=admin,proto3" json:"admin,omitempty" yaml:"admin"`
}

func (m *Params) Reset()         <span class="cov0" title="0">{ *m = Params{} }</span>
func (m *Params) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Params) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Params) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6cd5d1c7ef4e1c40, []int{0}
}</span>
func (m *Params) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Params.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Params) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Params.Merge(m, src)
}</span>
func (m *Params) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Params) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Params.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Params proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Params)(nil), "comdex.asset.v1beta1.Params")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("comdex/asset/v1beta1/params.proto", fileDescriptor_6cd5d1c7ef4e1c40) }</span>

var fileDescriptor_6cd5d1c7ef4e1c40 = []byte{
        // 197 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x52, 0x4c, 0xce, 0xcf, 0x4d,
        0x49, 0xad, 0xd0, 0x4f, 0x2c, 0x2e, 0x4e, 0x2d, 0xd1, 0x2f, 0x33, 0x4c, 0x4a, 0x2d, 0x49, 0x34,
        0xd4, 0x2f, 0x48, 0x2c, 0x4a, 0xcc, 0x2d, 0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x12, 0x81,
        0x28, 0xd1, 0x03, 0x2b, 0xd1, 0x83, 0x2a, 0x91, 0x12, 0x49, 0xcf, 0x4f, 0xcf, 0x07, 0x2b, 0xd0,
        0x07, 0xb1, 0x20, 0x6a, 0x95, 0x0c, 0xb8, 0xd8, 0x02, 0xc0, 0x7a, 0x85, 0xd4, 0xb8, 0x58, 0x13,
        0x53, 0x72, 0x33, 0xf3, 0x24, 0x18, 0x15, 0x18, 0x35, 0x38, 0x9d, 0x04, 0x3e, 0xdd, 0x93, 0xe7,
        0xa9, 0x4c, 0xcc, 0xcd, 0xb1, 0x52, 0x02, 0x0b, 0x2b, 0x05, 0x41, 0xa4, 0x9d, 0x02, 0x4f, 0x3c,
        0x94, 0x63, 0x58, 0xf1, 0x48, 0x8e, 0xe1, 0xc4, 0x23, 0x39, 0xc6, 0x0b, 0x8f, 0xe4, 0x18, 0x1f,
        0x3c, 0x92, 0x63, 0x9c, 0xf0, 0x58, 0x8e, 0xe1, 0xc2, 0x63, 0x39, 0x86, 0x1b, 0x8f, 0xe5, 0x18,
        0xa2, 0xf4, 0xd3, 0x33, 0x4b, 0x32, 0x4a, 0x93, 0xf4, 0x92, 0xf3, 0x73, 0xf5, 0x21, 0x4e, 0xd1,
        0xcd, 0x4f, 0x4b, 0xcb, 0x4c, 0xce, 0x4c, 0xcc, 0x81, 0xf2, 0xf5, 0x61, 0xee, 0x2f, 0xa9, 0x2c,
        0x48, 0x2d, 0x4e, 0x62, 0x03, 0xbb, 0xc5, 0x18, 0x10, 0x00, 0x00, 0xff, 0xff, 0xd0, 0x76, 0x46,
        0xb0, 0xdc, 0x00, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Admin) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Admin)
                copy(dAtA[i:], m.Admin)
                i = encodeVarintParams(dAtA, i, uint64(len(m.Admin)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintParams(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovParams(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Params) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Admin)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovParams(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovParams(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozParams(x uint64) (n int) <span class="cov0" title="0">{
        return sovParams(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Params) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Params: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Admin = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipParams(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipParams(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupParams
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthParams
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthParams        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowParams          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupParams = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/asset/v1beta1/querier.proto

package types

import (
        context "context"
        fmt "fmt"
        query "github.com/cosmos/cosmos-sdk/types/query"
        _ "github.com/gogo/protobuf/gogoproto"
        grpc1 "github.com/gogo/protobuf/grpc"
        proto "github.com/gogo/protobuf/proto"
        _ "google.golang.org/genproto/googleapis/api/annotations"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type QueryAssetsRequest struct {
        Pagination *query.PageRequest `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty" yaml:"pagination"`
}

func (m *QueryAssetsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryAssetsRequest{} }</span>
func (m *QueryAssetsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryAssetsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryAssetsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{0}
}</span>
func (m *QueryAssetsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryAssetsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryAssetsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryAssetsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryAssetsRequest.Merge(m, src)
}</span>
func (m *QueryAssetsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryAssetsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryAssetsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryAssetsRequest proto.InternalMessageInfo

type QueryAssetsResponse struct {
        Assets     []Asset             `protobuf:"bytes,1,rep,name=assets,proto3" json:"assets" yaml:"assets"`
        Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty" yaml:"pagination"`
}

func (m *QueryAssetsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryAssetsResponse{} }</span>
func (m *QueryAssetsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryAssetsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryAssetsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{1}
}</span>
func (m *QueryAssetsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryAssetsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryAssetsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryAssetsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryAssetsResponse.Merge(m, src)
}</span>
func (m *QueryAssetsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryAssetsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryAssetsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryAssetsResponse proto.InternalMessageInfo

type QueryAssetRequest struct {
        Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *QueryAssetRequest) Reset()         <span class="cov0" title="0">{ *m = QueryAssetRequest{} }</span>
func (m *QueryAssetRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryAssetRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryAssetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{2}
}</span>
func (m *QueryAssetRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryAssetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryAssetRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryAssetRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryAssetRequest.Merge(m, src)
}</span>
func (m *QueryAssetRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryAssetRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryAssetRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryAssetRequest proto.InternalMessageInfo

type QueryAssetResponse struct {
        Asset Asset `protobuf:"bytes,1,opt,name=asset,proto3" json:"asset" yaml:"asset"`
}

func (m *QueryAssetResponse) Reset()         <span class="cov0" title="0">{ *m = QueryAssetResponse{} }</span>
func (m *QueryAssetResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryAssetResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryAssetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{3}
}</span>
func (m *QueryAssetResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryAssetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryAssetResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryAssetResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryAssetResponse.Merge(m, src)
}</span>
func (m *QueryAssetResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryAssetResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryAssetResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryAssetResponse proto.InternalMessageInfo

type QueryPairsRequest struct {
        Pagination *query.PageRequest `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty" yaml:"pagination"`
}

func (m *QueryPairsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryPairsRequest{} }</span>
func (m *QueryPairsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryPairsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryPairsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{4}
}</span>
func (m *QueryPairsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryPairsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryPairsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryPairsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryPairsRequest.Merge(m, src)
}</span>
func (m *QueryPairsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryPairsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryPairsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryPairsRequest proto.InternalMessageInfo

type QueryPairsResponse struct {
        Pairs      []Pair              `protobuf:"bytes,1,rep,name=pairs,proto3" json:"pairs" yaml:"pairs"`
        Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty" yaml:"pagination"`
}

func (m *QueryPairsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryPairsResponse{} }</span>
func (m *QueryPairsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryPairsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryPairsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{5}
}</span>
func (m *QueryPairsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryPairsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryPairsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryPairsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryPairsResponse.Merge(m, src)
}</span>
func (m *QueryPairsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryPairsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryPairsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryPairsResponse proto.InternalMessageInfo

type QueryPairRequest struct {
        Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *QueryPairRequest) Reset()         <span class="cov0" title="0">{ *m = QueryPairRequest{} }</span>
func (m *QueryPairRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryPairRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryPairRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{6}
}</span>
func (m *QueryPairRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryPairRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryPairRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryPairRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryPairRequest.Merge(m, src)
}</span>
func (m *QueryPairRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryPairRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryPairRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryPairRequest proto.InternalMessageInfo

type QueryPairResponse struct {
        Pair Pair `protobuf:"bytes,1,opt,name=pair,proto3" json:"pair" yaml:"pair"`
}

func (m *QueryPairResponse) Reset()         <span class="cov0" title="0">{ *m = QueryPairResponse{} }</span>
func (m *QueryPairResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryPairResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryPairResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{7}
}</span>
func (m *QueryPairResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryPairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryPairResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryPairResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryPairResponse.Merge(m, src)
}</span>
func (m *QueryPairResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryPairResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryPairResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryPairResponse proto.InternalMessageInfo

type QueryParamsRequest struct {
}

func (m *QueryParamsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryParamsRequest{} }</span>
func (m *QueryParamsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryParamsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryParamsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{8}
}</span>
func (m *QueryParamsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryParamsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryParamsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsRequest.Merge(m, src)
}</span>
func (m *QueryParamsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryParamsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryParamsRequest proto.InternalMessageInfo

type QueryParamsResponse struct {
        Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params" yaml:"params"`
}

func (m *QueryParamsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryParamsResponse{} }</span>
func (m *QueryParamsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryParamsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryParamsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{9}
}</span>
func (m *QueryParamsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryParamsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryParamsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsResponse.Merge(m, src)
}</span>
func (m *QueryParamsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryParamsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryParamsResponse proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*QueryAssetsRequest)(nil), "comdex.asset.v1beta1.QueryAssetsRequest")
        proto.RegisterType((*QueryAssetsResponse)(nil), "comdex.asset.v1beta1.QueryAssetsResponse")
        proto.RegisterType((*QueryAssetRequest)(nil), "comdex.asset.v1beta1.QueryAssetRequest")
        proto.RegisterType((*QueryAssetResponse)(nil), "comdex.asset.v1beta1.QueryAssetResponse")
        proto.RegisterType((*QueryPairsRequest)(nil), "comdex.asset.v1beta1.QueryPairsRequest")
        proto.RegisterType((*QueryPairsResponse)(nil), "comdex.asset.v1beta1.QueryPairsResponse")
        proto.RegisterType((*QueryPairRequest)(nil), "comdex.asset.v1beta1.QueryPairRequest")
        proto.RegisterType((*QueryPairResponse)(nil), "comdex.asset.v1beta1.QueryPairResponse")
        proto.RegisterType((*QueryParamsRequest)(nil), "comdex.asset.v1beta1.QueryParamsRequest")
        proto.RegisterType((*QueryParamsResponse)(nil), "comdex.asset.v1beta1.QueryParamsResponse")
}</span>

func init() <span class="cov8" title="1">{
        proto.RegisterFile("comdex/asset/v1beta1/querier.proto", fileDescriptor_00878c412a69d054)
}</span>

var fileDescriptor_00878c412a69d054 = []byte{
        // 671 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x95, 0x41, 0x6b, 0x13, 0x41,
        0x14, 0xc7, 0x77, 0x63, 0x13, 0x70, 0x52, 0xc5, 0x4e, 0x53, 0x28, 0x69, 0xdc, 0xa4, 0x13, 0x69,
        0x52, 0xc1, 0x5d, 0x1a, 0x6f, 0xde, 0x8c, 0xa0, 0xa0, 0x97, 0x76, 0xbd, 0x88, 0x50, 0x61, 0x92,
        0x4c, 0xd7, 0x81, 0x24, 0xb3, 0xdd, 0xd9, 0x14, 0x83, 0x78, 0x11, 0x11, 0xf1, 0x24, 0xf8, 0x25,
        0xfc, 0x10, 0x5e, 0x7a, 0xcb, 0xb1, 0xe0, 0xc5, 0x53, 0xd0, 0xc4, 0x4f, 0xd0, 0x4f, 0x20, 0x3b,
        0x33, 0xbb, 0xd9, 0xd4, 0x64, 0xb7, 0x17, 0x7b, 0x5b, 0x26, 0xef, 0xff, 0xde, 0xff, 0xf7, 0xe6,
        0xbd, 0x09, 0x40, 0x6d, 0xd6, 0xeb, 0x90, 0x37, 0x16, 0xe6, 0x9c, 0xf8, 0xd6, 0xc9, 0x5e, 0x8b,
        0xf8, 0x78, 0xcf, 0x3a, 0x1e, 0x10, 0x8f, 0x12, 0xcf, 0x74, 0x3d, 0xe6, 0x33, 0x58, 0x90, 0x31,
        0xa6, 0x88, 0x31, 0x55, 0x4c, 0xf1, 0x6e, 0x9b, 0xf1, 0x1e, 0xe3, 0x56, 0x0b, 0x73, 0x22, 0x04,
        0xc3, 0x48, 0xee, 0x62, 0x87, 0xf6, 0xb1, 0x4f, 0x59, 0x5f, 0x66, 0x28, 0x16, 0x1c, 0xe6, 0x30,
        0xf1, 0x69, 0x05, 0x5f, 0xea, 0xb4, 0xe4, 0x30, 0xe6, 0x74, 0x89, 0x85, 0x5d, 0x6a, 0xe1, 0x7e,
        0x9f, 0xf9, 0x42, 0xc2, 0xd5, 0xaf, 0x95, 0x85, 0xce, 0xa4, 0x07, 0x19, 0x51, 0x5e, 0x18, 0xe1,
        0x62, 0xaa, 0x8c, 0x17, 0xb7, 0x97, 0x04, 0x78, 0xb8, 0xa7, 0xaa, 0x20, 0x0e, 0xe0, 0x41, 0xe0,
        0xfd, 0x61, 0x10, 0xc2, 0x6d, 0x72, 0x3c, 0x20, 0xdc, 0x87, 0x87, 0x00, 0xcc, 0x18, 0x36, 0xf5,
        0x8a, 0x5e, 0xcf, 0x37, 0x76, 0x4c, 0x09, 0x6c, 0x06, 0xc0, 0xa6, 0x00, 0x0e, 0x7b, 0x61, 0xee,
        0x63, 0x87, 0x28, 0x6d, 0x73, 0xe3, 0x7c, 0x5c, 0x5e, 0x1b, 0xe2, 0x5e, 0xf7, 0x01, 0x9a, 0xe5,
        0x40, 0x76, 0x2c, 0x21, 0x3a, 0xd5, 0xc1, 0xfa, 0x5c, 0x55, 0xee, 0xb2, 0x3e, 0x27, 0xf0, 0x29,
        0xc8, 0x09, 0xab, 0x7c, 0x53, 0xaf, 0x5c, 0xab, 0xe7, 0x1b, 0x5b, 0xe6, 0xa2, 0xce, 0x9b, 0x42,
        0xd5, 0xdc, 0x18, 0x8d, 0xcb, 0xda, 0xf9, 0xb8, 0x7c, 0x43, 0xd6, 0x92, 0x42, 0x64, 0xab, 0x0c,
        0xf0, 0xd5, 0x1c, 0x42, 0x46, 0x20, 0xd4, 0x52, 0x11, 0xa4, 0x91, 0xcb, 0x30, 0x54, 0xc1, 0xda,
        0x0c, 0x21, 0xec, 0xdb, 0x4d, 0x90, 0xa1, 0x1d, 0xd1, 0xaf, 0x15, 0x3b, 0x43, 0x3b, 0xe8, 0x30,
        0xde, 0xdd, 0x08, 0xf3, 0x09, 0xc8, 0x0a, 0x93, 0xaa, 0xb1, 0x89, 0x94, 0x05, 0x45, 0xb9, 0x1a,
        0xa3, 0x44, 0xb6, 0xd4, 0x23, 0x4f, 0x79, 0xd8, 0xc7, 0xd4, 0xbb, 0xaa, 0xbb, 0xfb, 0xae, 0x2b,
        0x26, 0x55, 0x54, 0x31, 0x3d, 0x06, 0xd9, 0x60, 0xf0, 0xc2, 0x9b, 0x2b, 0x2e, 0x66, 0x0a, 0x34,
        0x17, 0x91, 0x84, 0x0c, 0xd9, 0x52, 0xfe, 0xdf, 0xaf, 0x0d, 0x81, 0x5b, 0x91, 0xfb, 0x65, 0xb7,
        0xf6, 0x22, 0xd6, 0xd6, 0x08, 0xf0, 0x11, 0x58, 0x09, 0x1c, 0xaa, 0x86, 0x26, 0xf1, 0xad, 0x2b,
        0xbe, 0xfc, 0x8c, 0x0f, 0xd9, 0x42, 0x8c, 0x0a, 0x51, 0xef, 0x82, 0x15, 0x54, 0xf5, 0x51, 0x4b,
        0x6d, 0x43, 0x78, 0xaa, 0x2a, 0x3e, 0x03, 0x39, 0xb9, 0xaa, 0xaa, 0x66, 0x69, 0x59, 0xcd, 0x20,
        0xe6, 0xe2, 0x3a, 0x48, 0x25, 0xb2, 0x55, 0x8a, 0xc6, 0x69, 0x16, 0xac, 0x8a, 0x22, 0xcf, 0x89,
        0x77, 0x42, 0xdb, 0x04, 0x7e, 0xd2, 0x41, 0x3e, 0xb6, 0x83, 0xb0, 0xbe, 0x38, 0xfb, 0xbf, 0x8f,
        0x43, 0x71, 0xf7, 0x12, 0x91, 0x12, 0x01, 0xdd, 0x79, 0xff, 0xe3, 0xcf, 0xd7, 0x8c, 0x01, 0x4b,
        0xd6, 0xf2, 0xc7, 0x8c, 0xc3, 0xcf, 0x3a, 0x00, 0x33, 0x35, 0xac, 0xa5, 0xe5, 0x0f, 0x8d, 0xd4,
        0xd3, 0x03, 0x95, 0x8f, 0x5d, 0xe1, 0xa3, 0x0a, 0xb7, 0x93, 0x7c, 0x58, 0x6f, 0x69, 0xe7, 0x1d,
        0xfc, 0x10, 0x9a, 0x11, 0xf3, 0x9d, 0x68, 0x26, 0xbe, 0x76, 0x89, 0x66, 0xe6, 0x56, 0x05, 0x55,
        0x85, 0x99, 0xdb, 0x70, 0xcb, 0x5a, 0xfa, 0x7e, 0x73, 0xf8, 0x51, 0x07, 0xd7, 0x23, 0x2d, 0xdc,
        0x49, 0x49, 0x1e, 0x9a, 0xa8, 0xa5, 0xc6, 0x29, 0x0f, 0x75, 0xe1, 0x01, 0xc1, 0x4a, 0x82, 0x07,
        0xd9, 0x8f, 0x68, 0x4e, 0xe4, 0x9c, 0xc1, 0x64, 0xce, 0xd8, 0x58, 0x27, 0xce, 0xc9, 0xfc, 0xa8,
        0xa7, 0xcd, 0x89, 0x9c, 0xe1, 0xe6, 0xc1, 0xe8, 0xb7, 0xa1, 0x7d, 0x9b, 0x18, 0xda, 0x68, 0x62,
        0xe8, 0x67, 0x13, 0x43, 0xff, 0x35, 0x31, 0xf4, 0x2f, 0x53, 0x43, 0x3b, 0x9b, 0x1a, 0xda, 0xcf,
        0xa9, 0xa1, 0xbd, 0xb4, 0x1c, 0xea, 0xbf, 0x1e, 0xb4, 0x82, 0xc2, 0x2a, 0xd3, 0x3d, 0x76, 0x74,
        0x44, 0xdb, 0x14, 0x77, 0xc3, 0xcc, 0x61, 0x6e, 0x7f, 0xe8, 0x12, 0xde, 0xca, 0x89, 0x7f, 0xc1,
        0xfb, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x4d, 0xb5, 0x9c, 0xc5, 0x07, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryServiceClient is the client API for QueryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryServiceClient interface {
        QueryAssets(ctx context.Context, in *QueryAssetsRequest, opts ...grpc.CallOption) (*QueryAssetsResponse, error)
        QueryAsset(ctx context.Context, in *QueryAssetRequest, opts ...grpc.CallOption) (*QueryAssetResponse, error)
        QueryPairs(ctx context.Context, in *QueryPairsRequest, opts ...grpc.CallOption) (*QueryPairsResponse, error)
        QueryPair(ctx context.Context, in *QueryPairRequest, opts ...grpc.CallOption) (*QueryPairResponse, error)
        QueryParams(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error)
}

type queryServiceClient struct {
        cc grpc1.ClientConn
}

func NewQueryServiceClient(cc grpc1.ClientConn) QueryServiceClient <span class="cov0" title="0">{
        return &amp;queryServiceClient{cc}
}</span>

func (c *queryServiceClient) QueryAssets(ctx context.Context, in *QueryAssetsRequest, opts ...grpc.CallOption) (*QueryAssetsResponse, error) <span class="cov0" title="0">{
        out := new(QueryAssetsResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.QueryService/QueryAssets", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryServiceClient) QueryAsset(ctx context.Context, in *QueryAssetRequest, opts ...grpc.CallOption) (*QueryAssetResponse, error) <span class="cov0" title="0">{
        out := new(QueryAssetResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.QueryService/QueryAsset", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryServiceClient) QueryPairs(ctx context.Context, in *QueryPairsRequest, opts ...grpc.CallOption) (*QueryPairsResponse, error) <span class="cov0" title="0">{
        out := new(QueryPairsResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.QueryService/QueryPairs", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryServiceClient) QueryPair(ctx context.Context, in *QueryPairRequest, opts ...grpc.CallOption) (*QueryPairResponse, error) <span class="cov0" title="0">{
        out := new(QueryPairResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.QueryService/QueryPair", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryServiceClient) QueryParams(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error) <span class="cov0" title="0">{
        out := new(QueryParamsResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.QueryService/QueryParams", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// QueryServiceServer is the server API for QueryService service.
type QueryServiceServer interface {
        QueryAssets(context.Context, *QueryAssetsRequest) (*QueryAssetsResponse, error)
        QueryAsset(context.Context, *QueryAssetRequest) (*QueryAssetResponse, error)
        QueryPairs(context.Context, *QueryPairsRequest) (*QueryPairsResponse, error)
        QueryPair(context.Context, *QueryPairRequest) (*QueryPairResponse, error)
        QueryParams(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error)
}

// UnimplementedQueryServiceServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServiceServer struct {
}

func (*UnimplementedQueryServiceServer) QueryAssets(ctx context.Context, req *QueryAssetsRequest) (*QueryAssetsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method QueryAssets not implemented")
}</span>
func (*UnimplementedQueryServiceServer) QueryAsset(ctx context.Context, req *QueryAssetRequest) (*QueryAssetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method QueryAsset not implemented")
}</span>
func (*UnimplementedQueryServiceServer) QueryPairs(ctx context.Context, req *QueryPairsRequest) (*QueryPairsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method QueryPairs not implemented")
}</span>
func (*UnimplementedQueryServiceServer) QueryPair(ctx context.Context, req *QueryPairRequest) (*QueryPairResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method QueryPair not implemented")
}</span>
func (*UnimplementedQueryServiceServer) QueryParams(ctx context.Context, req *QueryParamsRequest) (*QueryParamsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method QueryParams not implemented")
}</span>

func RegisterQueryServiceServer(s grpc1.Server, srv QueryServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_QueryService_serviceDesc, srv)
}</span>

func _QueryService_QueryAssets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryAssetsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryAssets(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.QueryService/QueryAssets",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryAssets(ctx, req.(*QueryAssetsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _QueryService_QueryAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryAssetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryAsset(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.QueryService/QueryAsset",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryAsset(ctx, req.(*QueryAssetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _QueryService_QueryPairs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryPairsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryPairs(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.QueryService/QueryPairs",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryPairs(ctx, req.(*QueryPairsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _QueryService_QueryPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryPairRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryPair(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.QueryService/QueryPair",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryPair(ctx, req.(*QueryPairRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _QueryService_QueryParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryParamsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryParams(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.QueryService/QueryParams",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryParams(ctx, req.(*QueryParamsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _QueryService_serviceDesc = grpc.ServiceDesc{
        ServiceName: "comdex.asset.v1beta1.QueryService",
        HandlerType: (*QueryServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "QueryAssets",
                        Handler:    _QueryService_QueryAssets_Handler,
                },
                {
                        MethodName: "QueryAsset",
                        Handler:    _QueryService_QueryAsset_Handler,
                },
                {
                        MethodName: "QueryPairs",
                        Handler:    _QueryService_QueryPairs_Handler,
                },
                {
                        MethodName: "QueryPair",
                        Handler:    _QueryService_QueryPair_Handler,
                },
                {
                        MethodName: "QueryParams",
                        Handler:    _QueryService_QueryParams_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "comdex/asset/v1beta1/querier.proto",
}

func (m *QueryAssetsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryAssetsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryAssetsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryAssetsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryAssetsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryAssetsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov0" title="0">if len(m.Assets) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Assets) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Assets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryAssetRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryAssetRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryAssetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuerier(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryAssetResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryAssetResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryAssetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *QueryPairsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryPairsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryPairsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryPairsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryPairsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryPairsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov0" title="0">if len(m.Pairs) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Pairs) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Pairs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryPairRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryPairRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryPairRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuerier(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryPairResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryPairResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryPairResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Pair.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *QueryParamsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryParamsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *QueryParamsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryParamsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func encodeVarintQuerier(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovQuerier(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *QueryAssetsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                l = m.Pagination.Size()
                n += 1 + l + sovQuerier(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryAssetsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Assets) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Assets </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovQuerier(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if m.Pagination != nil </span><span class="cov0" title="0">{
                l = m.Pagination.Size()
                n += 1 + l + sovQuerier(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryAssetRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuerier(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryAssetResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Asset.Size()
        n += 1 + l + sovQuerier(uint64(l))
        return n</span>
}

func (m *QueryPairsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                l = m.Pagination.Size()
                n += 1 + l + sovQuerier(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryPairsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Pairs) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Pairs </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovQuerier(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if m.Pagination != nil </span><span class="cov0" title="0">{
                l = m.Pagination.Size()
                n += 1 + l + sovQuerier(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryPairRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuerier(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryPairResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Pair.Size()
        n += 1 + l + sovQuerier(uint64(l))
        return n</span>
}

func (m *QueryParamsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *QueryParamsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Params.Size()
        n += 1 + l + sovQuerier(uint64(l))
        return n</span>
}

func sovQuerier(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozQuerier(x uint64) (n int) <span class="cov0" title="0">{
        return sovQuerier(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *QueryAssetsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryAssetsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryAssetsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Pagination == nil </span><span class="cov0" title="0">{
                                m.Pagination = &amp;query.PageRequest{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryAssetsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryAssetsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryAssetsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Assets = append(m.Assets, Asset{})
                        if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Pagination == nil </span><span class="cov0" title="0">{
                                m.Pagination = &amp;query.PageResponse{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryAssetRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryAssetRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryAssetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryAssetResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryAssetResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryAssetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryPairsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryPairsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryPairsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Pagination == nil </span><span class="cov0" title="0">{
                                m.Pagination = &amp;query.PageRequest{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryPairsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryPairsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryPairsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pairs", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Pairs = append(m.Pairs, Pair{})
                        if err := m.Pairs[len(m.Pairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Pagination == nil </span><span class="cov0" title="0">{
                                m.Pagination = &amp;query.PageResponse{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryPairRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryPairRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryPairRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryPairResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryPairResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryPairResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryParamsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryParamsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipQuerier(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupQuerier
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthQuerier
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthQuerier        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowQuerier          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupQuerier = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: comdex/asset/v1beta1/querier.proto

/*
Package types is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package types

import (
        "context"
        "io"
        "net/http"

        "github.com/golang/protobuf/descriptor"
        "github.com/golang/protobuf/proto"
        "github.com/grpc-ecosystem/grpc-gateway/runtime"
        "github.com/grpc-ecosystem/grpc-gateway/utilities"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/grpclog"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ = descriptor.ForMessage
var _ = metadata.Join

var (
        filter_QueryService_QueryAssets_0 = &amp;utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}
)

func request_QueryService_QueryAssets_0(ctx context.Context, marshaler runtime.Marshaler, client QueryServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryAssetsRequest
        var metadata runtime.ServerMetadata

        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_QueryService_QueryAssets_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.QueryAssets(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_QueryService_QueryAssets_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryAssetsRequest
        var metadata runtime.ServerMetadata

        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_QueryService_QueryAssets_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.QueryAssets(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_QueryService_QueryAsset_0(ctx context.Context, marshaler runtime.Marshaler, client QueryServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryAssetRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "id")
        }</span>

        <span class="cov0" title="0">protoReq.Id, err = runtime.Uint64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "id", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.QueryAsset(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_QueryService_QueryAsset_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryAssetRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "id")
        }</span>

        <span class="cov0" title="0">protoReq.Id, err = runtime.Uint64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "id", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.QueryAsset(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

var (
        filter_QueryService_QueryPairs_0 = &amp;utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}
)

func request_QueryService_QueryPairs_0(ctx context.Context, marshaler runtime.Marshaler, client QueryServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryPairsRequest
        var metadata runtime.ServerMetadata

        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_QueryService_QueryPairs_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.QueryPairs(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_QueryService_QueryPairs_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryPairsRequest
        var metadata runtime.ServerMetadata

        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_QueryService_QueryPairs_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.QueryPairs(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_QueryService_QueryPair_0(ctx context.Context, marshaler runtime.Marshaler, client QueryServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryPairRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "id")
        }</span>

        <span class="cov0" title="0">protoReq.Id, err = runtime.Uint64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "id", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.QueryPair(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_QueryService_QueryPair_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryPairRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "id")
        }</span>

        <span class="cov0" title="0">protoReq.Id, err = runtime.Uint64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "id", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.QueryPair(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_QueryService_QueryParams_0(ctx context.Context, marshaler runtime.Marshaler, client QueryServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryParamsRequest
        var metadata runtime.ServerMetadata

        msg, err := client.QueryParams(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err

}</span>

func local_request_QueryService_QueryParams_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryParamsRequest
        var metadata runtime.ServerMetadata

        msg, err := server.QueryParams(ctx, &amp;protoReq)
        return msg, metadata, err

}</span>

// RegisterQueryServiceHandlerServer registers the http handlers for service QueryService to "mux".
// UnaryRPC     :call QueryServiceServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterQueryServiceHandlerFromEndpoint instead.
func RegisterQueryServiceHandlerServer(ctx context.Context, mux *runtime.ServeMux, server QueryServiceServer) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_QueryService_QueryAssets_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_QueryService_QueryAssets_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryAssets_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryAsset_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_QueryService_QueryAsset_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryAsset_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryPairs_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_QueryService_QueryPairs_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryPairs_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryPair_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_QueryService_QueryPair_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryPair_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryParams_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_QueryService_QueryParams_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryParams_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

// RegisterQueryServiceHandlerFromEndpoint is same as RegisterQueryServiceHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterQueryServiceHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) <span class="cov0" title="0">{
        conn, err := grpc.Dial(endpoint, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                }()
        }()

        <span class="cov0" title="0">return RegisterQueryServiceHandler(ctx, mux, conn)</span>
}

// RegisterQueryServiceHandler registers the http handlers for service QueryService to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterQueryServiceHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error <span class="cov0" title="0">{
        return RegisterQueryServiceHandlerClient(ctx, mux, NewQueryServiceClient(conn))
}</span>

// RegisterQueryServiceHandlerClient registers the http handlers for service QueryService
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "QueryServiceClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "QueryServiceClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "QueryServiceClient" to call the correct interceptors.
func RegisterQueryServiceHandlerClient(ctx context.Context, mux *runtime.ServeMux, client QueryServiceClient) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_QueryService_QueryAssets_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_QueryService_QueryAssets_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryAssets_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryAsset_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_QueryService_QueryAsset_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryAsset_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryPairs_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_QueryService_QueryPairs_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryPairs_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryPair_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_QueryService_QueryPair_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryPair_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryParams_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_QueryService_QueryParams_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryParams_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

var (
        pattern_QueryService_QueryAssets_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"comdex", "asset", "v1beta1", "assets"}, "", runtime.AssumeColonVerbOpt(true)))

        pattern_QueryService_QueryAsset_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3, 1, 0, 4, 1, 5, 4}, []string{"comdex", "asset", "v1beta1", "assets", "id"}, "", runtime.AssumeColonVerbOpt(true)))

        pattern_QueryService_QueryPairs_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"comdex", "asset", "v1beta1", "pairs"}, "", runtime.AssumeColonVerbOpt(true)))

        pattern_QueryService_QueryPair_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3, 1, 0, 4, 1, 5, 4}, []string{"comdex", "asset", "v1beta1", "pairs", "id"}, "", runtime.AssumeColonVerbOpt(true)))

        pattern_QueryService_QueryParams_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"comdex", "asset", "v1beta1", "params"}, "", runtime.AssumeColonVerbOpt(true)))
)

var (
        forward_QueryService_QueryAssets_0 = runtime.ForwardResponseMessage

        forward_QueryService_QueryAsset_0 = runtime.ForwardResponseMessage

        forward_QueryService_QueryPairs_0 = runtime.ForwardResponseMessage

        forward_QueryService_QueryPair_0 = runtime.ForwardResponseMessage

        forward_QueryService_QueryParams_0 = runtime.ForwardResponseMessage
)
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
